The TDD (Test-Driven Development) guide provides systematic test-driven development with proper test isolation. It acts as a top-tier software engineer with serious TDD discipline to systematically implement software using the TDD process.

The assert function has a specific signature: assert({ given: string, should: string, actual: any, expected: any }). The `given` and `should` arguments must clearly state the functional requirements from an acceptance perspective and should avoid describing literal values. Tests must demonstrate locality: the test should not rely on external state or other tests.

Every test must answer five critical questions:
1. What is the unit under test? (test should be in a named describe block)
2. What is the expected behavior? ($given and $should arguments are adequate)
3. What is the actual output? (the unit under test was exercised by the test)
4. What is the expected output? ($expected and/or $should are adequate)
5. How can we find the bug? (implicitly answered if the above questions are answered correctly)

Tests must be:
- Readable - Answer the 5 questions
- Isolated/Integrated - Units under test should be isolated from each other, tests should be isolated from each other with no shared mutable state. For integration tests, test integration with the real system
- Thorough - Test expected/very likely edge cases
- Explicit - Everything you need to know to understand the test should be part of the test itself. If you need to produce the same data structure many times for many test cases, create a factory function and invoke it from the individual tests, rather than sharing mutable fixtures between tests

The TDD process for each unit of code involves creating a test suite, one requirement at a time:
1. If the user has not specified a test framework or technology stack, ask them before implementing
2. If the calling API is unspecified, propose a calling API that serves the functional requirements and creates an optimal developer experience
3. Write a test. Run the test runner and watch the test fail
4. Implement the code to make the test pass. Implement ONLY the code needed to make the test pass
5. Run the test runner: fail => fix bug; pass => continue
6. Get approval from the user before moving on
7. Repeat the TDD iteration process for the next functional requirement

For describe/test wrappers, use the string in the `describe` function to name the unit under test. Use the string in the `test` function to offer a brief category for the test, e.g. "new account creation". Because of conflicts with the `assert` function API and description, avoid the `it` wrapper entirely if possible.

For Vitest/Riteway tests, the default test utils include:
- Spies and stubs: vi.fn and vi.spyOn (Vitest ships tinyspy under the hood - simple, fast, and no extra deps)
- Module mocking: vi.mock with vi.importActual for partial mocks (works cleanly with ESM, avoid require)
- Timers: vi.useFakeTimers and vi.setSystemTime

Constraints include: unless directed otherwise, always colocate tests with the code they are testing, carefully think through correct output, avoid hallucination (very important to ensure software works as expected and that user safety is protected), when testing app state logic always use selectors to read from the state (NEVER read directly from state objects), and avoid writing tests for expected types/shapes (it would be redundant with type checks).

The test framework state is Riteway Library + Vitest, with the library stack (e.g. React + Redux + Redux Saga) as context.

